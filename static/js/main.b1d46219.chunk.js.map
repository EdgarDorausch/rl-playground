{"version":3,"sources":["Playground/Utils.ts","Playground/Agent.ts","Playground/Algorithm/index.ts","Playground/State.ts","Playground/Algorithm/PolicyUpdator.ts","Playground/Algorithm/ParameterUpdator.ts","Playground/RenderHandler.ts","Playground/MazeCellRenderer.ts","App.tsx","Playground/Maze.ts","serviceWorker.ts","index.tsx"],"names":["directionArray","Array","fill","map","_","i","sleep","milliseconds","Promise","resolve","setTimeout","range","stop","out","push","Direction","viewModeList","numberOfDirections","Directional","directionValueInitializer","directionValues","this","d","value","maxDirection","maxValue","direction","directionValue","other","k","StochasticDirectional","l1Norm","reduce","acc","val","Error","r","Math","random","console","warn","sum","log","Agent","startState","stateTensor","algorithm","state","oldState","action","chooseAction","newState","getNeighbor","reward","afterAction","Algorithm","parameterUpdator","policyUpdator","updateParameters","updatePolicy","policy","getDirectionByDistribution","State","_x","_y","_t","isValid","q","newPos","x","y","t","NORTH","EAST","SOUTH","WEST","NORTH_EAST","SOUTH_EAST","SOUTH_WEST","NORTH_WEST","STALL","newX","newY","newT","neighbor","get","getFutureState","unsafeGet","StateTensor","maxX","maxY","maxTimer","stateBuilder","state3DList","modT","EpsilonGreedyPolicyUpdator","Ɛ","currentState","greedyAction","getMaximum","newPolicy","UpdatedEpsilonGreedyPolicyUpdator","updateEpsilon","init","iteration","TemporalDifferenceLearning","learningRate","discountFactor","newVal","RenderHandler","agent","cellDim","cellSize","cellPadding","mazeCellRenderer","onTimeTravelProgressChange","cellStriding","canvasSize","halfCellSize","halfDiagonalSectionSize","ctx","travelTime","doTimeTravel","viewMode","doStartNewEpisode","stepCounter","stepCounterDOMElem","timer","timerDOMElem","positions","as","bs","a","b","cross","getCellColor","bind","getTriangleVisibility","draw","document","getElementById","canvas","width","height","getContext","getColor","getTriangleColor","showTriangles","pos","resetTransform","translate","fillStyle","beginPath","lineTo","closePath","rotate","PI","moveTo","fillRect","arc","window","requestAnimationFrame","doStep","progress","updateHTML","innerHTML","toString","setup","update","MyMazeCellRenderer","policyMode","linScale","d3","domain","powerScale","pow","currentTime","policyBuffer","itNum","itNumHalf","floor","maxEntropy","sizeX","sizeY","updatePolicyBuffer","currentPolicyField","sub","add","normalize","inverseEntropy","getEntropy","scale","FlexContainer","children","className","style","display","justifyContent","App","props","renderHandler","mazeStr","startPos","targetPositions","char","charAt","numberOfTargets","length","tX","tY","sX","sY","e","constructMaze","setState","timeTravelProgress","vertical","onChange","event","target","options","selectedIndex","text","key","onClick","intent","animate","id","backgroundColor","border","borderRadius","start","then","React","Component","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b1d46219.chunk.js","sourcesContent":["// Helper functions\n\ntype Array9 = [number, number, number, number, number, number, number, number, number];\nconst directionArray = new Array(9).fill(null).map((_,i) => i) as Array9;\n\nexport function translate(x: number, y: number): string {\n  return `translate(${x},${y})`\n}\n\nexport function visibility(visibility: boolean) {\n  return visibility ? 'visible' : 'hidden';\n}\n\nexport function sleep(milliseconds: number): Promise<void> {\n   return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\nexport function L2Norm(x: number, y: number): number {\n  return Math.sqrt(x*x + y*y);\n}\n\nexport function chooseRandomArrayElement<T>(a: T[]): T {\n  const len = a.length;\n  const idx = Math.floor(Math.random() * len);\n  return a[idx];\n}\n\nexport function range(stop: number): number[] {\n  const out: number[] = [];\n  for(let i=0; i<stop; i++) {\n    out.push(i)\n  }\n  return out;\n}\n\nexport function cross<A,B>(as: A[], bs: B[]): [A,B][] {\n  const out: [A,B][] = [];\n  for(let a of as) {\n    for(let b of bs) {\n      out.push([a,b]);\n    }\n  }\n  return out;\n}\n\nexport const viewModeList = ['reward' , 'value' , 'q-function' , 'policy', 'policy_aie'] as ['reward' , 'value' , 'q-function' , 'policy',  'policy_aie'];\nexport type ViewMode = typeof viewModeList[number];\n\nexport enum Direction {\n  NORTH,\n  EAST,\n  SOUTH,\n  WEST,\n\n  NORTH_EAST,\n  SOUTH_EAST,\n  SOUTH_WEST,\n  NORTH_WEST,\n\n  STALL\n}\n\nexport const numberOfDirections = 9;\n\ntype DirectionValueInitializer = (direction: Direction) => number;\nexport class Directional {\n\n  protected directionValues: Array9;\n\n  constructor(directionValueInitializer: DirectionValueInitializer = () => 0) {\n    this.directionValues = directionArray.map(directionValueInitializer) as Array9;\n  }\n\n  get(d: Direction): number {\n    return this.directionValues[d];\n  }\n  set(d: Direction, value: number): void {\n    this.directionValues[d] = value;\n  }\n\n  /**\n   * Returns an object with the direction whose value is maximal and the according value\n   */\n  getMaximum(): {direction: Direction, directionValue: number} {\n    let maxDirection = 0;\n    let maxValue = 0;\n    \n    // Find maximum by traversing all direction values\n    for(let d=0; d<numberOfDirections; d++) {\n      if(this.directionValues[d] > maxValue) {\n        maxValue = this.directionValues[d];\n        maxDirection = d;\n      }\n    }\n    \n    return {\n      direction: maxDirection,\n      directionValue: maxValue\n    }\n  }\n\n  /**\n   * Adding the values of an other directional in an inplace way\n   */\n  add(other: Directional) {\n    // For all directions\n    for(let d = 0; d<numberOfDirections; d++){\n      this.directionValues[d] += other.directionValues[d];\n    }\n  }\n\n  /**\n   * Adding the values of an other directional in an inplace way\n   */\n  sub(other: Directional) {\n    // For all directions\n    for(let d = 0; d<numberOfDirections; d++){\n      this.directionValues[d] -= other.directionValues[d];\n    }\n  }\n\n  /**\n   * \n   * Inplace scaling of the direction values\n   */\n  scale(k: number) {\n    for(let d = 0; d<numberOfDirections; d++){\n      this.directionValues[d] *= k;\n    }\n  }\n}\n\nconst pseudoZero = 0.00001;\nexport class StochasticDirectional extends Directional {\n\n  constructor(directionValueInitializer: DirectionValueInitializer = () => 1/numberOfDirections) {\n    super(directionValueInitializer);\n  }\n\n   normalize() {\n    const l1Norm = this.directionValues.reduce((acc, val) => val+acc, 0);\n    if(l1Norm === 0) {\n      throw new Error('Sum of all elements in StochasticDirectional is Zero, so normalization has failed!')\n    }\n    for(let d=0; d<numberOfDirections; d++)\n      this.directionValues[d] /= l1Norm;\n  }\n\n  check() {\n    const l1Norm = this.directionValues.reduce((acc, val) => val+acc, 0);\n    if(l1Norm === 0) {\n      throw new Error('Sum of all elements in StochasticDirectional is Zero, so normalization has failed!')\n    }\n    for(let val of this.directionValues) {\n      if(val < -pseudoZero) {\n        throw new Error('Elements in StochasticDirectional should not be negative!')\n      }\n    }\n  }\n\n  set(d: Direction, value: number): void {\n    super.set(d, value);\n  }\n\n  getDirectionByDistribution(): Direction {\n    let r = Math.random();\n\n    // For all directions\n    for(let d = 0; d<numberOfDirections; d++){\n      const val = this.directionValues[d];\n      if(r < val) {\n        return d;\n      } else {\n        r -= val;\n      }\n    }\n\n    console.warn('Encountered non normalized distribution. This could caused by rounding errors!')\n    // Return last direction\n    return numberOfDirections-1;\n  }\n\n  getEntropy(): number {\n\n    let sum = 0\n    // For all directions\n    for(let d = 0; d<numberOfDirections; d++){\n      sum -= this.directionValues[d]*Math.log(this.directionValues[d])\n    }\n\n    return sum;\n  }\n}","import { Algorithm } from './Algorithm/index';\nimport { State, StateTensor } from './State';\n\nexport class Agent {\n  public state: State;\n\n  constructor(\n    startState: State,\n    protected stateTensor: StateTensor,\n    private algorithm: Algorithm\n  ) {\n    this.state = startState;\n  }\n   \n  doStep() {\n    const oldState = this.state;\n    const action = this.algorithm.chooseAction(this.state);\n    const newState = this.state.getNeighbor(action);\n    const reward = newState.reward;\n\n    this.state = newState;\n\n    this.algorithm.afterAction(this.stateTensor,oldState, action, reward, newState);\n  }\n}","import { Direction } from '../Utils';\nimport { State, StateTensor } from '../State';\nimport { PolicyUpdator } from './PolicyUpdator';\nimport { ParameterUpdator } from './ParameterUpdator';\n\n\n/**\n * Handles the controlling and learning of the agent\n */\nexport class Algorithm {\n\n  // TODO: parameter initializer\n  constructor(\n    private parameterUpdator: ParameterUpdator,\n    private policyUpdator: PolicyUpdator,\n  ) {}\n\n  /**\n   * This method should be invoked after the agent has taken an action. It updates the parameters of the \n   * algorithm (e.g value/q-function) and the policy-distribution according to the `parameterUpdator` and the\n   * `policyUpdator` of the algorith.\n   * \n   * @param stateTensor whole state tensor\n   * @param oldState state before taking action\n   * @param action action taken\n   * @param reward reward yielded by taking the action\n   * @param newState state after taking action\n   */\n  afterAction(stateTensor: StateTensor, oldState: State, action: Direction, reward: number, newState: State): void {\n    this.parameterUpdator.updateParameters(stateTensor, oldState, action, reward, newState);\n    this.policyUpdator.updatePolicy(stateTensor, newState);\n  }\n  /**\n   * Selecting an action according the policy (of the current state of the agent)\n   * @param state current state of the agent \n   */\n  chooseAction(state: State): Direction {\n    return state.policy.getDirectionByDistribution();\n  }\n\n  startNewEpisode(): void {\n    throw Error('Method has to be implemented!')\n  };\n  endEpisode(): void {\n    throw Error('Method has to be implemented!')\n  }\n}","import { Directional, StochasticDirectional, Direction } from './Utils';\n\nexport class State {\n\n  constructor(\n    private stateTensor: StateTensor,\n    \n    private _x: number,\n    private _y: number,\n    private _t: number,\n\n    public isValid: boolean,\n\n    public reward: number,\n    public value: number,\n    public q: Directional,\n    public policy: StochasticDirectional\n  ) {}\n\n  get t() {\n    return this._t;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n\n  /**\n   * Returning the neighbor state according to the given direction.\n   * `null` is returned if there is no neighbor inside the stateTensor or the neighbor is not valid\n   */\n  getNeighbor(direction: Direction): State {\n    let newPos;\n    const x = this._x;\n    const y = this._y;\n    const t = this._t;\n    switch(direction) {\n      case Direction.NORTH:\n        newPos = [x, y-1, t+1];\n        break;\n      case Direction.EAST:\n        newPos = [1+x, y, t+1];\n        break;\n      case Direction.SOUTH:\n        newPos = [x, y+1, t+1];\n        break;\n      case Direction.WEST:\n        newPos = [x-1, y, t+1];\n        break;\n      case Direction.NORTH_EAST:\n        newPos = [x+1, y-1, t+1];\n        break;\n      case Direction.SOUTH_EAST:\n        newPos = [1+x, y+1, t+1];\n        break;\n      case Direction.SOUTH_WEST:\n        newPos = [x-1, y+1, t+1];\n        break;\n      case Direction.NORTH_WEST:\n        newPos = [x-1, y-1, t+1];\n        break;\n      case Direction.STALL:\n        newPos = [x, y, t+1];\n        break;\n    default:\n        throw new Error(`Unknown direction: ${direction}`)\n    }\n    \n    const [newX,newY,newT] = newPos;\n    const neighbor = this.stateTensor.get(newX, newY, newT);\n\n    if (neighbor === null || !neighbor.isValid) {\n      return this.getFutureState();\n    }\n\n    return neighbor;\n  }\n\n  /**\n   * Returns the state with the same x and y coordinates but one time tick in the future\n   * TODO: write unit test \n   */\n  getFutureState() {\n    const {x, y, t} = this;\n    return this.stateTensor.unsafeGet(x,y,t+1); // entry with this indices should always exist\n  } \n}\n\n\nexport type StateBuilder = (x: number, y: number, t: number) => ({\n  isValid?: boolean,\n  reward?: number,\n  value?: number,\n  q?: Directional,\n  policy?: StochasticDirectional \n})\n\ntype State3DList = State[][][];\nexport class StateTensor {\n\n  private state3DList: State3DList;\n\n  constructor(\n    private maxX: number,\n    private maxY: number,\n    private maxTimer: number,\n    stateBuilder: StateBuilder\n  ) {\n    \n    this.state3DList = \n      new Array(maxX    ).fill(null).map((_,x) => \n      new Array(maxY    ).fill(null).map((_,y) => \n      new Array(maxTimer).fill(null).map((_,t) => {\n        const {\n          isValid,\n          reward,\n          value,\n          policy,\n          q\n        } = stateBuilder(x,y,t);\n        return new State(\n          this,\n          x,y,t,\n          isValid ?? true,\n          reward  ?? 0,\n          value   ?? 0,\n          q       ?? new Directional(),\n          policy  ?? new StochasticDirectional()\n        )}\n      )))\n  }\n\n  get(x: number, y: number, t: number): State|null {\n\n    // Check if x,y in bounds\n    if(0 <= x && x < this.maxX &&\n       0 <= y && y < this.maxY) {\n      const modT = ((t % this.maxTimer)+this.maxTimer) % this.maxTimer; // Map t to [0,maxTimer) interval\n      return(this.state3DList[x][y][modT])\n      \n    } else {\n      return null\n    }\n\n    \n  }\n\n  unsafeGet(x: number, y: number, t: number): State {\n\n    const state = this.get(x,y,t);\n    if(state === null) {\n      throw new Error(`Could not return state for (x,y,t)=(${x},${y},${t})`)\n    }\n\n    return state;\n  }\n\n  get sizeX() {\n    return this.maxX;\n  }\n\n  get sizeY() {\n    return this.maxY;\n  }\n\n  get sizeT() {\n    return this.maxTimer;\n  }\n}","import { State, StateTensor } from '../State';\nimport { Directional, StochasticDirectional, numberOfDirections } from '../Utils';\n\n/**\n * A `PolicyUpdator` is responsible for updating the policy (probability distribution) after the agent has taken an action.\n */\nexport interface PolicyUpdator {\n  updatePolicy(stateTensor: StateTensor, currentState: State): void;\n}\n\n/**\n * Generates a policy which selects a greedy action with probability Ɛ.\n * (action which maximizes the value function locally)\n */\nexport class EpsilonGreedyPolicyUpdator implements PolicyUpdator {\n\n  /**\n   * @param Ɛ Probability of taking a greedy action \n   */\n  constructor(protected Ɛ: number) {}\n\n  updatePolicy(stateTensor: StateTensor, currentState: State) {\n    const neighbors = new Directional(d => currentState.getNeighbor(d).value);\n\n    const greedyAction = neighbors.getMaximum().direction;\n    const newPolicy = new StochasticDirectional(action => \n      action === greedyAction ?\n      this.Ɛ / numberOfDirections + 1-this.Ɛ :\n      this.Ɛ / numberOfDirections\n    );\n    currentState.policy = newPolicy;\n  }\n}\n\n/**\n * Generates a policy which always selects the greedy action.\n * (action which maximizes the value function locally)\n */\nexport class GreedyPolicyUpdator extends EpsilonGreedyPolicyUpdator {\n  constructor() {\n    super(0);\n  }\n}\n\n\ntype UpdateEpsilon = (Ɛ: number, iteration: number) => number;\n/**\n * Generates a policy which selects a greedy action with a probability Ɛ.\n * This probability is updated on every iteration.\n */\nexport class UpdatedEpsilonGreedyPolicyUpdator extends EpsilonGreedyPolicyUpdator {\n  iteration: number = 0;\n\n  /**\n   * @param updateEpsilon Defines the update rule for Ɛ\n   * @param init Initial Ɛ value\n   */\n  constructor(protected updateEpsilon: UpdateEpsilon, protected init: number = 1) {\n    super(init)\n    this.Ɛ = init;\n  }\n\n  updatePolicy(stateTensor: StateTensor, currentState: State) {\n    this.iteration++;\n    this.Ɛ = this.updateEpsilon(this.Ɛ, this.iteration);\n    super.updatePolicy(stateTensor, currentState);\n  }\n}","import { Direction } from '../Utils';\nimport { State, StateTensor } from '../State';\n\n/**\n * A `ParameterUpdator` is responsible for updating the parameters of the algorith (e.g. value/q-function)\n * after the agent has taken an action.\n */\nexport interface ParameterUpdator {\n  /**\n   * After the agent has taken an action, this method should be invoked to update the parameters of the algorith (e.g. value/q-function)\n   * The input follows the SARS-Principle _((old-)state, action, reward, (new-)state)_.\n   * If the algorithm has to change the parameter for an arbitrary state the whole state tensor is given.\n   * \n   * @param stateTensor whole state tensor\n   * @param oldState state before taking action\n   * @param action action taken\n   * @param reward reward yielded by taking the action\n   * @param newState state after taking action\n   */\n  updateParameters(stateTensor: StateTensor, oldState: State, action: Direction, reward: number, newState: State): void;\n}\n\n\nexport class TemporalDifferenceLearning implements ParameterUpdator {\n\n  constructor(protected learningRate: number, protected discountFactor: number) {}\n\n  updateParameters(stateTensor: StateTensor, oldState: State, action: Direction, reward: number, newState: State) {\n    const newVal = \n    (1-this.learningRate) * oldState.value + \n        this.learningRate * (newState.reward + this.discountFactor*newState.value)\n  \n    oldState.value = newVal;\n  }\n}","import { ViewMode, sleep, cross, range, viewModeList, Direction } from './Utils';\nimport { Agent } from './Agent';\nimport { State, StateTensor } from './State';\nimport { MazeCellRenderer } from './MazeCellRenderer';\n\n\nexport class RenderHandler {\n  private cellStriding: number;\n  private canvasSize: number;\n  private halfCellSize: number;\n  private halfDiagonalSectionSize: number;\n\n  private ctx: CanvasRenderingContext2D|null = null;\n\n  private travelTime = 5_000_000; \n  public doTimeTravel =  false;\n  public viewMode: ViewMode = viewModeList[0];\n  public doStartNewEpisode =  false;\n  \n  private stepCounter = 0;\n  private stepCounterDOMElem: HTMLElement|null = null;\n\n  private timer = 0;\n  private timerDOMElem: HTMLElement|null = null;\n\n  private positions: [number, number][];\n\n\n  constructor(\n    private agent: Agent,\n    private stateTensor: StateTensor,\n    cellDim: number,\n    private cellSize: number,\n    private cellPadding: number,\n    private mazeCellRenderer: MazeCellRenderer,\n    private onTimeTravelProgressChange?: (t: number) => void\n  ) {\n    this.cellStriding = cellSize + cellPadding;\n    this.canvasSize = cellDim*(this.cellStriding) + cellPadding;\n    this.positions = cross(range(cellDim), range(cellDim));\n\n    this.halfCellSize = cellSize/2;\n    this.halfDiagonalSectionSize = cellSize/6;\n    this.getCellColor = this.getCellColor.bind(this);\n    this.getTriangleVisibility = this.getTriangleVisibility.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  private setup() {\n\n    this.stepCounterDOMElem = document.getElementById('stepCounter');\n    this.timerDOMElem = document.getElementById('timer');\n\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n    canvas.width = this.canvasSize;\n    canvas.height = this.canvasSize;\n    this.ctx = canvas.getContext('2d');\n  }\n\n  private getCellColor(state: State): string {\n    return this.mazeCellRenderer.getColor(this.viewMode, state);\n  }\n\n  private getTriangleColor(direction: Direction, state: State): string {\n    return this.mazeCellRenderer.getTriangleColor(this.viewMode, direction, state);\n  }\n\n  private getTriangleVisibility(state: State): boolean {\n    return this.mazeCellRenderer.showTriangles(this.viewMode, state);\n  }\n\n  private draw() {\n\n    if(this.ctx === null)\n      throw new Error('canvas 2d context is null! Is setup called before draw?');\n\n    this.timer = this.agent.state.t;\n\n    for(let pos of this.positions) {\n      const [x,y] = pos;\n      const state = this.stateTensor.unsafeGet(x, y, this.timer);\n\n      this.ctx.resetTransform()\n      this.ctx.translate(this.cellStriding*x + this.cellPadding, this.cellStriding*y + this.cellPadding);\n\n      const showTriangles = this.getTriangleVisibility(state);\n\n      if(showTriangles) {\n\n        this.ctx.translate(this.halfCellSize, this.halfCellSize);\n\n        // Render \"straight\" cell-sections\n        for(let direction=0; direction<4; direction++) {\n          this.ctx.fillStyle = this.getTriangleColor(direction, state);\n\n          this.ctx.beginPath();\n          //this.ctx.moveTo(0, 0);\n\n          this.ctx.lineTo(-this.halfDiagonalSectionSize, -this.halfDiagonalSectionSize);\n          this.ctx.lineTo(-this.halfDiagonalSectionSize, -this.halfCellSize);\n          this.ctx.lineTo(this.halfDiagonalSectionSize, -this.halfCellSize);\n          this.ctx.lineTo(this.halfDiagonalSectionSize, -this.halfDiagonalSectionSize);\n\n          this.ctx.closePath();\n          this.ctx.fill();\n\n          this.ctx.rotate(Math.PI / 2)\n        }\n\n        // Render \"diagonal\" cell-sections\n        for(let direction=4; direction<8; direction++) {\n          this.ctx.fillStyle = this.getTriangleColor(direction, state);\n\n          this.ctx.rotate(Math.PI / 2)\n\n          this.ctx.beginPath();\n          this.ctx.moveTo(this.halfDiagonalSectionSize, -this.halfDiagonalSectionSize);\n\n          this.ctx.lineTo(this.halfDiagonalSectionSize, -this.halfCellSize);\n          this.ctx.lineTo(this.halfCellSize, -this.halfCellSize);\n          this.ctx.lineTo(this.halfCellSize, -this.halfDiagonalSectionSize);\n\n          this.ctx.closePath();\n          this.ctx.fill();\n\n        }\n\n        this.ctx.fillStyle = this.getTriangleColor(9, state);\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.halfDiagonalSectionSize, -this.halfDiagonalSectionSize);\n        this.ctx.lineTo(this.halfDiagonalSectionSize, this.halfDiagonalSectionSize);\n        this.ctx.lineTo(-this.halfDiagonalSectionSize, this.halfDiagonalSectionSize);\n        this.ctx.lineTo(-this.halfDiagonalSectionSize, -this.halfDiagonalSectionSize);\n        this.ctx.closePath();\n        this.ctx.fill();\n\n      } else {\n        this.ctx.fillStyle = this.getCellColor(state);\n        this.ctx.fillRect(0,0, this.cellSize, this.cellSize);\n      }\n    }\n\n    this.ctx.resetTransform()\n    this.ctx.translate(\n      this.cellPadding + this.agent.state.x*this.cellStriding + this.cellSize/2,\n      this.cellPadding + this.agent.state.y*this.cellStriding + this.cellSize/2\n    );\n\n    this.ctx.fillStyle = 'green';\n    this.ctx.beginPath();\n    this.ctx.arc(0, 0, this.cellSize/2.2, 0, 2 * Math.PI);\n    this.ctx.fill();\n\n    window.requestAnimationFrame(this.draw);\n  }\n\n  private async update() {\n    this.stepCounter++;\n\n    if(this.doStartNewEpisode) {\n      this.doStartNewEpisode = false;\n      // TODO: this.agent.resetPosition();\n    }\n    \n    if(this.doTimeTravel) {\n      this.doTimeTravel = false;\n      for(let i = 0; i<this.travelTime; i++) {\n        this.stepCounter++;\n        this.agent.doStep();\n        const progress = i/this.travelTime;\n        if(progress%0.01 < 0.0000001) {\n          this.onTimeTravelProgressChange?.(progress);\n          this.updateHTML()\n          await sleep(1);\n        }\n      }\n      this.onTimeTravelProgressChange?.(0);\n    }\n    \n    this.agent.doStep();\n  }\n\n  private updateHTML() {\n    if(this.stepCounterDOMElem === null)\n      throw new Error('stepCounter DOM Element is null! Is setup called before draw?');\n    if(this.timerDOMElem === null)\n      throw new Error('timer DOM Element is null! Is setup called before draw?');\n\n    this.stepCounterDOMElem.innerHTML = this.stepCounter.toString();\n    this.timerDOMElem.innerHTML = this.timer.toString();\n  }\n\n  public async start() {\n    this.setup();\n\n    window.requestAnimationFrame(this.draw);\n\n    while(true) {\n      await this.update();\n      this.updateHTML()\n      await sleep(40);\n      // break;\n    }\n  }\n}","import { ViewMode, Direction, numberOfDirections, StochasticDirectional } from './Utils';\nimport { State, StateTensor } from './State';\nimport * as d3 from 'd3';\n\nexport interface MazeCellRenderer {\n  getColor(viewMode: ViewMode, state: State): string\n  getTriangleColor(viewMode: ViewMode, direction: Direction, state: State): string\n  showTriangles(viewMode: ViewMode, state: State): boolean\n}\n\ntype PolicyMode = 'Accumulated' | 'InverseEntropy'\n\nexport class MyMazeCellRenderer implements MazeCellRenderer {\n\n  private linScale = d3.scaleSequential(d3.interpolatePuOr).domain([0,1]);\n  private powerScale = (t: number) => d3.scaleSequential(d3.interpolatePuOr).domain([0,1])(Math.pow(t, 1/10));\n\n  private currentTime = 0;\n  private policyBuffer: StateTensor;\n\n  private itNum = 10;\n  private itNumHalf = Math.floor(this.itNum/2);\n\n  private maxEntropy = Math.log(numberOfDirections);\n\n  constructor(private stateTensor: StateTensor, private policyMode: PolicyMode = 'Accumulated') {\n    this.policyBuffer = new StateTensor(stateTensor.sizeX, stateTensor.sizeY, 1, () => ({policy: new StochasticDirectional(() => 0)}));\n    // this.initPolicyBuffer();\n    console.log(this.maxEntropy);\n  }\n\n  getColor(viewMode: ViewMode, state: State) {  \n    if(!state.isValid) {\n      return '#777';\n    }\n\n    switch(viewMode){\n      case 'reward':\n        return this.powerScale(state.reward);\n      case 'value':\n        return this.powerScale(state.value);\n      case 'policy':\n      case 'policy_aie':\n      case 'q-function':\n        return 'red';\n    }\n  }\n\n  getTriangleColor(viewMode: ViewMode, direction: Direction, state: State) {\n\n    if(!state.isValid){\n      return '#777';\n    }\n\n    switch(viewMode) {\n      case 'policy_aie': // AccumulatedInverseEntropy\n        if(this.currentTime !== state.t) \n          this.updatePolicyBuffer(state.t)\n        \n        const {x, y} = state;\n        const val = this.policyBuffer.unsafeGet(x,y,0).policy.get(direction);\n        return this.linScale(val);\n      case 'policy':\n        return this.linScale(state.policy.get(direction))\n      case 'q-function':\n        return this.linScale(state.q.get(direction));\n      case 'reward':\n      case 'value':\n        return 'red';\n    }\n  }\n\n  private updatePolicyBuffer(newT: number) {\n    this.currentTime = newT;\n    for(let x = 0; x < this.policyBuffer.sizeX; x++) {\n      for(let y = 0; y < this.policyBuffer.sizeY; y++) {\n        const currentPolicyField = this.policyBuffer.unsafeGet(x,y,0).policy;\n        currentPolicyField.sub(currentPolicyField);\n\n        for(let t=0; t < this.itNum; t++) {\n          currentPolicyField.add(this.stateTensor.unsafeGet(x,y,this.currentTime-t+this.itNumHalf).policy)\n        }\n\n        currentPolicyField.normalize()\n        const inverseEntropy = (this.maxEntropy - currentPolicyField.getEntropy())/this.maxEntropy;\n        currentPolicyField.scale(inverseEntropy);\n      }\n    }\n  }\n\n  showTriangles(viewMode: ViewMode, state: State) {\n\n    if(!state.isValid){\n      return false;\n    }\n\n    switch(viewMode) {\n      case 'policy':\n      case 'policy_aie':\n      case 'q-function':\n        return true;\n      case 'reward':\n      case 'value':\n        return false;\n    }\n  }\n}","import React from 'react';\nimport { Button, ControlGroup, ProgressBar } from '@blueprintjs/core';\nimport './App.css';\n\nimport {ViewMode, viewModeList} from './Playground/Utils';\nimport {constructMaze} from './Playground/Maze';\nimport { RenderHandler } from './Playground/RenderHandler';\nimport { MyMazeCellRenderer } from './Playground/MazeCellRenderer';\n\n\nconst FlexContainer: React.SFC<{width?: string|number}> = ({width, children}) => (\n  <div\n    className=\"FlexContainer\"\n    style={{\n      display: 'flex',\n      justifyContent: 'center',\n      width: '100%'\n    }}\n  >\n    <div style={{width}}>\n      {children}\n    </div>\n  </div>\n)\n\n\n// A simple maze\n// =========================\n// [\n//   '....#..........€',\n//   '....##..########',\n//   '........#.......',\n//   '##  #########...',\n//   '............#..#',\n//   '....#......##..#',\n//   '#####......#....',\n//   '.......#####....',\n//   '.......#......#.',\n//   '...#.........##.',\n//   '###########.....',\n//   '...#............',\n//   '...###...#######',\n//   '.....#..........',\n//   '.....#######....',\n//   '$...............',\n// ];\n\n// To complex structure\n// =========================\n// [\n//   '.........#......',\n//   '.........#......',\n//   '..........#€....',\n//   '...######.###...',\n//   '...#....#...#...',\n//   '...#.....#..#...',\n//   '...#..##....#...',\n//   '...#.########...',\n//   '...#..##....#...',\n//   '...#..$#€.#.#...',\n//   '...#...####.#...',\n//   '...#........#...',\n//   '...##########...',\n//   '................',\n//   '................',\n//   '................',\n// ];\n\n// Three targets. not enough time for traveling => interesting moves\n// =========================\n// [\n//   '.........#......',\n//   '.........#......',\n//   '.........#.€....',\n//   '...#####.####...',\n//   '...#........#...',\n//   '...#........#...',\n//   '...#..##...€#...',\n//   '...#.########...',\n//   '...#..##....#...',\n//   '...#..$.....#...',\n//   '...#......€.#...',\n//   '...#........#...',\n//   '...##########...',\n//   '................',\n//   '................',\n//   '................',\n// ];\n\n\n\nclass App extends React.Component<{},{timeTravelProgress: number}> {\n\n  private renderHandler: RenderHandler;\n\n  constructor(props: {}) {\n    super(props);\n\n    const mazeStr = [\n      '.........#......',\n      '.........#......',\n      '.........#.€....',\n      '...#####.####...',\n      '...#........#...',\n      '...#........#...',\n      '...#..##....#...',\n      '...#.########...',\n      '...#..##....#...',\n      '...#..$.....#...',\n      '...#......€.#...',\n      '...#........#...',\n      '...##########...',\n      '................',\n      '................',\n      '................',\n    ];\n    \n    const {stateTensor, agent} = constructMaze(mazeStr);\n    \n    this.renderHandler = new RenderHandler(\n      agent,\n      stateTensor,\n      16,\n      30,\n      2,\n      new MyMazeCellRenderer(stateTensor),\n      (t) => {this.setState({timeTravelProgress: t});}\n    )\n    \n    console.log(stateTensor)\n    console.log(agent);\n\n    this.state = {\n      timeTravelProgress: 0\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App bp3-dark\">\n        <h1>\n          RL Playground\n        </h1>\n        \n        \n        <FlexContainer>\n          <ControlGroup fill={false} vertical={false} >\n            <div className=\"bp3-select\">\n              <select onChange={(event) => {this.renderHandler.viewMode = event.target.options[event.target.selectedIndex].text as ViewMode}}>\n                {viewModeList.map(\n                  viewMode =>\n                  <option key={viewMode}>{viewMode}</option>\n                )}\n              </select>\n            </div>\n        \n            <Button\n              text=\"time travel\"\n              onClick={() => this.renderHandler.doTimeTravel = true}\n            />\n            {/* <Button\n              text=\"reset\"\n              onClick={() => this.renderHandler.doStartNewEpisode = true}\n            /> */}\n          </ControlGroup>\n          \n        </FlexContainer>\n\n        <br/>\n        <FlexContainer width={300}>\n            <ProgressBar\n              value={this.state.timeTravelProgress}\n              intent=\"success\"\n              animate={false}\n            />\n        </FlexContainer>\n       \n        {/* <Divider/> */}\n        <p>\n          <br/>\n          iteration: <i id=\"stepCounter\"></i>\n          <br/>\n          timer: <i id=\"timer\">55</i>\n        </p>\n\n        <canvas id=\"canvas\" style={{\n          backgroundColor: '#354553',\n          border: 'thick double rgb(64, 95, 112)',\n          borderRadius: 6\n        }}></canvas>\n      </div>\n    );\n  }\n\n  componentDidMount() {\n    this.renderHandler.start().then();\n  }\n}\n\n\nexport default App;\n","import {Agent} from './Agent';\nimport { Algorithm } from './Algorithm';\nimport { StateTensor, StateBuilder } from './State';\nimport { UpdatedEpsilonGreedyPolicyUpdator } from './Algorithm/PolicyUpdator';\nimport { TemporalDifferenceLearning } from './Algorithm/ParameterUpdator';\n\n\nexport function constructMaze(mazeStr: string[]): {stateTensor: StateTensor, agent: Agent} {\n  let startPos = [0,0];\n  let targetPositions: [number,number][] = [];\n  const cellDim = 16;\n\n  const map: (string|null)[][] = new Array(cellDim).fill(null).map(\n    (_) => new Array(cellDim).fill(null));\n  \n  for(let x = 0; x < 16; x++){\n    for(let y = 0; y < 16; y++) {\n      const char = mazeStr[y].charAt(x);\n      map[x][y] = char;\n      \n      if (char === '€')\n        targetPositions.push([x,y]);\n      \n      if(char === '$')\n        startPos = [x,y];\n    }\n  }\n\n  const numberOfTargets = targetPositions.length;\n  const maxTimer = 179;\n  const stateBuilder: StateBuilder = (x, y, t) => {\n    const char = map[x][y];\n\n    const [tX, tY] = targetPositions[Math.floor(t*numberOfTargets/maxTimer)];\n\n    return {\n      isValid: char !== '#',\n      reward:  x===tX && y===tY ? 1 : 0, // 1 - L2Norm(x-tX, y-tY)/L2Norm(16,16)\n      value: 5 // initializing with a high/optimistic value yields to faster convergence\n    }\n  }\n  \n  const stateTensor = new StateTensor(16, 16, maxTimer, stateBuilder);\n\n  const [sX, sY] = startPos;\n  const startState = stateTensor.unsafeGet(sX, sY, 0)\n  \n  const agent = new Agent(\n    startState,\n    stateTensor,\n    new Algorithm(\n      new TemporalDifferenceLearning(0.3, 0.5),\n      new UpdatedEpsilonGreedyPolicyUpdator(e => e*0.9999998),\n    )\n  );\n  \n  return {stateTensor, agent};  \n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}